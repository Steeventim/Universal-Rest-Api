# üß™ TP Niveau 6 - Base de donn√©es : Exercices Pratiques

## üéØ Vue d'ensemble des Exercices

**Dur√©e totale :** 6-7 heures  
**Progression :** Bronze ‚Üí Silver ‚Üí Gold  
**Objectif :** Ma√Ætriser l'int√©gration des bases de donn√©es dans les APIs REST

---

## ü•â **NIVEAU BRONZE** - Configuration de Base (2-3h)

### Exercice 1 : Setup MongoDB avec Mongoose (45min)

#### üéØ Objectif

Configurer MongoDB et cr√©er vos premiers mod√®les avec Mongoose.

#### üìã Instructions

1. **Installation et configuration**

   ```bash
   # Installer les d√©pendances MongoDB
   npm install mongodb mongoose @types/mongoose

   # D√©marrer MongoDB avec Docker
   docker run -d --name mongo-tp -p 27017:27017 mongo:6.0
   ```

2. **Cr√©er la configuration MongoDB**

   - Impl√©menter `src/database/config/mongodb.ts`
   - Pattern Singleton pour la connexion
   - Gestion des erreurs de connexion

3. **Cr√©er le mod√®le Item pour MongoDB**

   ```typescript
   // Sch√©ma avec validation compl√®te
   - name: string (requis, max 100 chars)
   - description: string (optionnel, max 500 chars)
   - price: number (requis, positif)
   - category: enum ['electronique', 'vetement', 'livre', 'autre']
   - tags: string[] (optionnel)
   - isActive: boolean (d√©faut: true)
   - timestamps automatiques
   ```

4. **Cr√©er des index pour la performance**
   - Index de recherche textuelle sur name/description
   - Index compos√© sur category/isActive
   - Index simple sur price

#### ‚úÖ Tests de Validation

```bash
# Test de connexion
curl http://localhost:3000/api/health/mongodb

# Test CRUD basique
curl -X POST http://localhost:3000/api/items \
  -H "Content-Type: application/json" \
  -d '{"name":"Test MongoDB","price":99.99,"category":"electronique"}'

# V√©rifier dans MongoDB
mongosh
> use api_tp
> db.items.find()
```

#### üéØ Crit√®res de R√©ussite

- [ ] Connexion MongoDB stable
- [ ] Mod√®le Mongoose avec validation
- [ ] Index cr√©√©s et fonctionnels
- [ ] CRUD basique op√©rationnel

---

### Exercice 2 : Setup PostgreSQL avec Prisma (45min)

#### üéØ Objectif

Configurer PostgreSQL et utiliser Prisma comme ORM moderne.

#### üìã Instructions

1. **Installation et initialisation**

   ```bash
   # Installer Prisma
   npm install prisma @prisma/client
   npm install --save-dev @types/pg

   # Initialiser Prisma
   npx prisma init

   # D√©marrer PostgreSQL
   docker run -d --name postgres-tp \
     -e POSTGRES_DB=api_tp \
     -e POSTGRES_USER=postgres \
     -e POSTGRES_PASSWORD=password \
     -p 5432:5432 postgres:15
   ```

2. **D√©finir le sch√©ma Prisma**

   ```prisma
   // prisma/schema.prisma
   model Item {
     id          Int      @id @default(autoincrement())
     name        String   @db.VarChar(100)
     description String?  @db.VarChar(500)
     price       Decimal  @db.Decimal(10, 2)
     category    Category
     tags        String[]
     isActive    Boolean  @default(true)
     createdAt   DateTime @default(now())
     updatedAt   DateTime @updatedAt

     @@index([category, isActive])
     @@index([price])
     @@map("items")
   }
   ```

3. **G√©n√©rer et ex√©cuter les migrations**

   ```bash
   npx prisma migrate dev --name init
   npx prisma generate
   ```

4. **Cr√©er la configuration PostgreSQL**
   - Client Prisma avec logging
   - M√©thodes de connexion/d√©connexion
   - Gestion des erreurs

#### ‚úÖ Tests de Validation

```bash
# Test de connexion
curl http://localhost:3000/api/health/postgresql

# Test avec Prisma Studio
npx prisma studio

# Test CRUD
curl -X POST http://localhost:3000/api/items \
  -H "Content-Type: application/json" \
  -d '{"name":"Test PostgreSQL","price":149.99,"category":"livre"}'
```

#### üéØ Crit√®res de R√©ussite

- [ ] PostgreSQL connect√© via Prisma
- [ ] Sch√©ma de donn√©es migr√©
- [ ] Client Prisma configur√©
- [ ] Prisma Studio accessible

---

### Exercice 3 : Interface Repository Pattern (60min)

#### üéØ Objectif

Impl√©menter le pattern Repository pour abstraire l'acc√®s aux donn√©es.

#### üìã Instructions

1. **Cr√©er l'interface IItemRepository**

   ```typescript
   interface IItemRepository {
     findAll(options?: FindAllOptions): Promise<IItem[]>;
     findById(id: string): Promise<IItem | null>;
     create(item: Omit<IItem, "id">): Promise<IItem>;
     update(id: string, item: Partial<IItem>): Promise<IItem | null>;
     delete(id: string): Promise<boolean>;
     findByCategory(category: string): Promise<IItem[]>;
     search(query: string): Promise<IItem[]>;
     count(filter?: any): Promise<number>;
   }
   ```

2. **Impl√©menter MongoItemRepository**

   - Toutes les m√©thodes avec Mongoose
   - Gestion des erreurs sp√©cifiques MongoDB
   - Optimisations des requ√™tes

3. **Impl√©menter PostgresItemRepository**

   - Toutes les m√©thodes avec Prisma
   - Conversion des types Prisma vers interface
   - Gestion des erreurs PostgreSQL

4. **Cr√©er un Factory Pattern**
   ```typescript
   class RepositoryFactory {
     static createItemRepository(): IItemRepository {
       const dbType = process.env.DB_TYPE || "mongodb";

       switch (dbType) {
         case "mongodb":
           return new MongoItemRepository();
         case "postgres":
           return new PostgresItemRepository();
         default:
           throw new Error(`Database type ${dbType} not supported`);
       }
     }
   }
   ```

#### ‚úÖ Tests de Validation

```bash
# Test avec MongoDB
DB_TYPE=mongodb npm run test:repository

# Test avec PostgreSQL
DB_TYPE=postgres npm run test:repository

# Test du factory pattern
npm run test:factory
```

#### üéØ Crit√®res de R√©ussite

- [ ] Interface Repository compl√®te
- [ ] Impl√©mentations MongoDB et PostgreSQL
- [ ] Factory pattern fonctionnel
- [ ] Tests passants pour les deux bases

---

## ü•à **NIVEAU SILVER** - Int√©gration Avanc√©e (3-4h)

### Exercice 4 : Cache Layer avec Redis (90min)

#### üéØ Objectif

Int√©grer Redis pour am√©liorer les performances avec un syst√®me de cache intelligent.

#### üìã Instructions

1. **Setup Redis**

   ```bash
   # Installer Redis
   npm install redis ioredis @types/ioredis

   # D√©marrer Redis
   docker run -d --name redis-tp -p 6379:6379 redis:7-alpine
   ```

2. **Cr√©er RedisClient avec Singleton**

   ```typescript
   // Configuration avec retry et monitoring
   - Connexion avec options avanc√©es
   - Gestion des √©v√©nements (connect, error, ready)
   - Pool de connexions si n√©cessaire
   ```

3. **Impl√©menter CacheService**

   ```typescript
   // M√©thodes de cache
   - getItem(id): IItem | null
   - setItem(id, item, ttl): void
   - deleteItem(id): void
   - getItemsList(key): IItem[] | null
   - setItemsList(key, items, ttl): void
   - invalidateItem(id): void
   - invalidateListsCache(): void
   - getCacheStats(): CacheStats
   ```

4. **Strat√©gies de cache**
   - Cache-aside pattern
   - TTL adaptatif selon le type de donn√©e
   - Invalidation en cascade
   - Compression pour gros objets

#### ‚úÖ Tests de Validation

```bash
# Test de performance sans cache
time curl http://localhost:3000/api/items

# Test de performance avec cache
time curl http://localhost:3000/api/items # 2√®me appel

# V√©rifier Redis
redis-cli
> KEYS *
> GET "item:1"

# Stats du cache
curl http://localhost:3000/api/cache/stats
```

#### üéØ Crit√®res de R√©ussite

- [ ] Redis connect√© et stable
- [ ] Cache service complet
- [ ] Am√©lioration mesurable des performances
- [ ] Invalidation du cache fonctionnelle

---

### Exercice 5 : Service Int√©gr√© avec Cache (60min)

#### üéØ Objectif

Modifier le ItemService pour int√©grer transparentement le cache.

#### üìã Instructions

1. **Modifier ItemService**

   ```typescript
   // Pattern cache-aside dans chaque m√©thode
   getById(id):
     1. V√©rifier cache
     2. Si pas trouv√© ‚Üí base de donn√©es
     3. Mettre en cache le r√©sultat

   getAll(options):
     1. Cr√©er cl√© de cache bas√©e sur options
     2. V√©rifier cache
     3. Si pas trouv√© ‚Üí base de donn√©es + cache

   create(item):
     1. Cr√©er en base
     2. Mettre en cache
     3. Invalider les listes

   update(id, data):
     1. Modifier en base
     2. Mettre √† jour le cache
     3. Invalider les listes

   delete(id):
     1. Supprimer de la base
     2. Invalider le cache
   ```

2. **Gestion intelligente du cache**

   - TTL diff√©renci√© par type d'op√©ration
   - Cache conditionnel selon la taille des donn√©es
   - Monitoring des hit/miss ratios

3. **Fallback et r√©silience**
   - Fonctionnement si Redis est down
   - Circuit breaker pattern
   - Logs de performance

#### ‚úÖ Tests de Validation

```bash
# Test de performance compl√®te
npm run benchmark:api

# Test de r√©silience (arr√™ter Redis)
docker stop redis-tp
curl http://localhost:3000/api/items # Doit fonctionner

# Red√©marrer Redis
docker start redis-tp
curl http://localhost:3000/api/items # Cache doit se reconstruire
```

#### üéØ Crit√®res de R√©ussite

- [ ] Service avec cache transparent
- [ ] Performance am√©lior√©e significativement
- [ ] R√©silience si cache indisponible
- [ ] Monitoring des performances

---

### Exercice 6 : Migrations et Seeders (90min)

#### üéØ Objectif

Cr√©er un syst√®me complet de migrations et de donn√©es de test.

#### üìã Instructions

1. **Scripts de migration PostgreSQL**

   ```sql
   -- migrations/001_init_schema.sql
   CREATE TYPE category_enum AS ENUM (...);
   CREATE TABLE items (...);
   CREATE INDEX ...;

   -- migrations/002_add_full_text_search.sql
   CREATE INDEX idx_items_search ON items
   USING gin(to_tsvector('french', name || ' ' || description));

   -- migrations/003_add_audit_fields.sql
   ALTER TABLE items ADD COLUMN created_by INTEGER;
   ALTER TABLE items ADD COLUMN updated_by INTEGER;
   ```

2. **Seeders avec donn√©es r√©alistes**

   ```typescript
   // Cr√©er 1000+ items vari√©s
   - Diff√©rentes cat√©gories √©quilibr√©es
   - Prix r√©alistes par cat√©gorie
   - Tags pertinents
   - Descriptions d√©taill√©es
   ```

3. **Scripts de gestion**

   ```typescript
   // scripts/migrate.ts
   - Ex√©cution s√©quentielle des migrations
   - Tracking des versions appliqu√©es
   - Rollback si erreur

   // scripts/seed.ts
   - Nettoyage optionnel des donn√©es existantes
   - Insertion par batch pour performance
   - Progression et statistiques
   ```

4. **Migration MongoDB √©quivalente**
   ```typescript
   // Syst√®me de versions pour MongoDB
   - Collection migrations pour tracking
   - Scripts d'√©volution du sch√©ma
   - Validation des donn√©es existantes
   ```

#### ‚úÖ Tests de Validation

```bash
# Migration PostgreSQL
npm run db:migrate

# Seeding
npm run db:seed

# V√©rification des donn√©es
curl http://localhost:3000/api/items?limit=100

# Test de performance avec gros dataset
time curl http://localhost:3000/api/items/search?q=smartphone

# Rollback et re-migration
npm run db:rollback
npm run db:migrate
```

#### üéØ Crit√®res de R√©ussite

- [ ] Syst√®me de migration complet
- [ ] Seeders avec donn√©es vari√©es (1000+ items)
- [ ] Scripts de gestion automatis√©s
- [ ] Performance stable avec gros dataset

---

## ü•á **NIVEAU GOLD** - Production Ready (2-3h)

### Exercice 7 : Optimisations de Performance (90min)

#### üéØ Objectif

Optimiser les performances pour un environnement de production.

#### üìã Instructions

1. **Analyse des performances actuelles**

   ```typescript
   // Middleware de monitoring des requ√™tes
   - Temps d'ex√©cution par endpoint
   - Analyse des requ√™tes lentes (>1s)
   - Statistiques de cache hit/miss
   - Monitoring de la m√©moire
   ```

2. **Optimisations MongoDB**

   ```typescript
   // Index compos√©s optimis√©s
   { category: 1, price: 1, isActive: 1 }
   { tags: 1, isActive: 1 }
   { name: "text", description: "text" }

   // Aggregation pipeline pour requ√™tes complexes
   - Pagination efficace avec $skip/$limit
   - Recherche avec scoring
   - Statistiques par cat√©gorie
   ```

3. **Optimisations PostgreSQL**

   ```sql
   -- Index partiels pour requ√™tes fr√©quentes
   CREATE INDEX idx_active_items ON items(category, price)
   WHERE is_active = true;

   -- Index GIN pour recherche full-text
   CREATE INDEX idx_search_items ON items
   USING gin(to_tsvector('french', name || ' ' || description));

   -- Statistiques et VACUUM automatique
   ```

4. **Connection Pooling et Optimisations**

   ```typescript
   // MongoDB avec pool de connexions
   mongoose.connect(uri, {
     maxPoolSize: 10,
     minPoolSize: 2,
     maxIdleTimeMS: 30000,
     serverSelectionTimeoutMS: 5000,
   });

   // PostgreSQL avec Prisma pool
   new PrismaClient({
     datasources: {
       db: {
         url: DATABASE_URL + "?connection_limit=20&pool_timeout=20",
       },
     },
   });
   ```

#### ‚úÖ Tests de Validation

```bash
# Load testing
npm install -g artillery
artillery quick --count 100 --num 10 http://localhost:3000/api/items

# Analyse des index
# MongoDB
db.items.getIndexes()
db.items.explain("executionStats").find({category: "electronique"})

# PostgreSQL
EXPLAIN ANALYZE SELECT * FROM items WHERE category = 'electronique';

# Monitoring continu
npm run performance:monitor
```

#### üéØ Crit√®res de R√©ussite

- [ ] R√©ponse <200ms pour 95% des requ√™tes
- [ ] Index optimis√©s et utilis√©s
- [ ] Connection pooling configur√©
- [ ] Load testing r√©ussi (100 users concurrent)

---

### Exercice 8 : Backup et Recovery (60min)

#### üéØ Objectif

Impl√©menter une strat√©gie compl√®te de sauvegarde et r√©cup√©ration.

#### üìã Instructions

1. **Scripts de backup automatis√©s**

   ```bash
   #!/bin/bash
   # scripts/backup-mongodb.sh
   mongodump --host localhost:27017 --db api_tp \
     --out /backups/mongodb/$(date +%Y%m%d_%H%M%S)

   # scripts/backup-postgresql.sh
   pg_dump -h localhost -U postgres api_tp \
     > /backups/postgresql/api_tp_$(date +%Y%m%d_%H%M%S).sql
   ```

2. **Strat√©gie de r√©tention**

   ```typescript
   // Politique de backup
   - Backup complet quotidien
   - Backup incr√©mental toutes les 6h
   - R√©tention : 7 jours quotidiens, 4 semaines hebdomadaires
   - Backup avant chaque migration
   ```

3. **Scripts de restauration**

   ```bash
   # Test de restauration compl√®te
   # Cr√©er une base de test
   # Restaurer le backup
   # Valider l'int√©grit√© des donn√©es
   ```

4. **Monitoring et alertes**
   ```typescript
   // V√©rification de l'int√©grit√©
   - Checksum des backups
   - Test de restauration automatique
   - Alertes si backup √©choue
   - M√©triques de taille et dur√©e
   ```

#### ‚úÖ Tests de Validation

```bash
# Test backup complet
npm run backup:all

# Test de restauration
npm run restore:test

# Simulation de disaster recovery
docker stop postgres-tp mongo-tp redis-tp
npm run disaster:recovery

# Validation de l'int√©grit√©
npm run backup:verify
```

#### üéØ Crit√®res de R√©ussite

- [ ] Backup automatis√© fonctionnel
- [ ] Restauration test√©e et valid√©e
- [ ] Strat√©gie de r√©tention impl√©ment√©e
- [ ] Tests de disaster recovery r√©ussis

---

### Exercice 9 : Monitoring et Alertes Production (90min)

#### üéØ Objectif

Mettre en place un monitoring complet pour la production.

#### üìã Instructions

1. **M√©triques de base de donn√©es**

   ```typescript
   // Dashboard de m√©triques
   - Connexions actives
   - Temps de r√©ponse des requ√™tes
   - Utilisation de la m√©moire
   - Taille des bases de donn√©es
   - Hit ratio du cache
   ```

2. **Health checks avanc√©s**

   ```typescript
   // Endpoint /health d√©taill√©
   {
     "status": "healthy",
     "databases": {
       "mongodb": { "status": "connected", "latency": "5ms" },
       "postgresql": { "status": "connected", "latency": "3ms" },
       "redis": { "status": "connected", "latency": "1ms" }
     },
     "performance": {
       "avgResponseTime": "150ms",
       "slowQueries": 2,
       "cacheHitRate": "95%"
     }
   }
   ```

3. **Alertes configurables**

   ```typescript
   // Seuils d'alerte
   - Latence > 500ms ‚Üí Warning
   - Latence > 1000ms ‚Üí Critical
   - Cache hit rate < 80% ‚Üí Warning
   - Connexions > 80% pool ‚Üí Warning
   - Disk space < 20% ‚Üí Critical
   ```

4. **Logs structur√©s**
   ```typescript
   // Logging avec Winston
   - Logs de performance par requ√™te
   - Logs d'erreur avec context
   - Logs de s√©curit√© (tentatives d'acc√®s)
   - Rotation automatique des logs
   ```

#### ‚úÖ Tests de Validation

```bash
# Test du monitoring
curl http://localhost:3000/health

# Simulation de charge pour d√©clencher alertes
npm run stress:test

# V√©rification des logs
tail -f logs/api.log | grep ERROR

# Dashboard de m√©triques
curl http://localhost:3000/metrics
```

#### üéØ Crit√®res de R√©ussite

- [ ] Monitoring complet fonctionnel
- [ ] Health checks d√©taill√©s
- [ ] Alertes configur√©es et test√©es
- [ ] Logs structur√©s et rotatifs

---

## üî• **BONUS - D√©fis Avanc√©s**

### D√©fi 1 : Multi-tenant avec bases s√©par√©es

```typescript
// Gestion de plusieurs clients avec bases d√©di√©es
- Routing automatique selon le tenant
- Migrations par tenant
- Backup isol√© par client
```

### D√©fi 2 : R√©plication Master/Slave

```typescript
// Configuration haute disponibilit√©
- Master pour √©criture, Slaves pour lecture
- Failover automatique
- Consistance √©ventuelle
```

### D√©fi 3 : Sharding horizontal

```typescript
// Partitionnement des donn√©es
- Strat√©gie de partitionnement par cat√©gorie
- Router de requ√™tes automatique
- Gestion des requ√™tes cross-shard
```

---

## üìä Grille d'√âvaluation Globale

### Bronze (Fondamentaux) - 60 points

- Configuration bases de donn√©es : 20 pts
- Repository pattern : 20 pts
- Tests d'int√©gration : 20 pts

### Silver (Interm√©diaire) - 80 points

- Cache Redis int√©gr√© : 30 pts
- Migrations/Seeders : 25 pts
- Performance optimis√©e : 25 pts

### Gold (Production) - 100 points

- Monitoring complet : 35 pts
- Backup/Recovery : 35 pts
- Optimisations avanc√©es : 30 pts

**Score total possible : 240 points**

**Seuils de validation :**

- Bronze : 45+ points (75%)
- Silver : 60+ points (75%)
- Gold : 75+ points (75%)

---

üéØ **Objectif Final :** Ma√Ætriser compl√®tement l'int√©gration des bases de donn√©es dans une API REST de niveau production, avec cache, monitoring et r√©silience.

‚û°Ô∏è **Prochaine √©tape :** [TP Niveau 7 - API Avanc√©e](./EXERCICES_07.md)
