# üß™ TP Niveau 4 : Tests

## üéØ **Objectifs**

- Comprendre l'importance des tests dans le d√©veloppement d'API
- Ma√Ætriser les tests unitaires et d'int√©gration
- √âcrire des tests robustes avec Node.js Test Runner
- Impl√©menter des mocks et des stubs
- Atteindre une couverture de code satisfaisante

## ‚è±Ô∏è **Dur√©e estim√©e :** 4-5 heures

---

## üìã **Pr√©requis**

### Ce que vous devez ma√Ætriser

- ‚úÖ Op√©rations CRUD compl√®tes (TP 2)
- ‚úÖ Validation avec Zod (TP 3)
- ‚úÖ Compr√©hension du flow de requ√™te
- ‚úÖ Utilisation de Swagger et curl

### V√©rification rapide

```bash
# D√©marrer le serveur
npm start

# Tester la validation
curl -X POST http://localhost:3001/api/items \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","category":"electronics","price":10}'
```

---

## üöÄ **Configuration du TP**

### 1. R√©cup√©ration du code

```bash
git checkout tp-04-tests
npm install
```

### 2. Structure des tests

```
tests/
‚îú‚îÄ‚îÄ unit/                 # Tests unitaires
‚îÇ   ‚îú‚îÄ‚îÄ services/        # Tests des services
‚îÇ   ‚îú‚îÄ‚îÄ controllers/     # Tests des contr√¥leurs
‚îÇ   ‚îî‚îÄ‚îÄ schemas/         # Tests de validation
‚îú‚îÄ‚îÄ integration/         # Tests d'int√©gration
‚îÇ   ‚îî‚îÄ‚îÄ api/            # Tests end-to-end de l'API
‚îî‚îÄ‚îÄ fixtures/           # Donn√©es de test
    ‚îî‚îÄ‚îÄ items.js        # Items de test
```

### 3. Scripts de test disponibles

```bash
# Tous les tests
npm test

# Tests unitaires seulement
npm run test:unit

# Tests d'int√©gration seulement
npm run test:integration

# Tests avec surveillance des changements
npm run test:watch

# Couverture de code
npm run test:coverage
```

---

## üìö **Concepts fondamentaux**

### **üî¨ Types de tests**

#### **Tests unitaires**

- Testent une fonction/m√©thode isol√©e
- Rapides √† ex√©cuter
- Utilisent des mocks pour les d√©pendances
- Exemple : Tester `itemsService.createItem()`

#### **Tests d'int√©gration**

- Testent l'interaction entre composants
- Plus lents mais plus r√©alistes
- Testent le flow complet
- Exemple : POST /api/items ‚Üí Controller ‚Üí Service ‚Üí Response

#### **Tests end-to-end (E2E)**

- Testent l'application compl√®te
- Simulent un utilisateur r√©el
- Les plus lents mais les plus fiables
- Exemple : Sc√©nario complet CRUD

### **üé≠ Mocks et Stubs**

#### **Mock**

```javascript
// Remplace compl√®tement une d√©pendance
const mockService = {
  createItem: () => ({ id: "1", name: "Mock Item" }),
};
```

#### **Stub**

```javascript
// Remplace seulement certaines m√©thodes
const originalMethod = service.createItem;
service.createItem = () => "stubbed result";
// Puis restaurer: service.createItem = originalMethod;
```

#### **Spy**

```javascript
// Surveille les appels sans changer le comportement
let callCount = 0;
const originalMethod = service.createItem;
service.createItem = (...args) => {
  callCount++;
  return originalMethod.apply(service, args);
};
```

---

## üß™ **Exercices pratiques**

### **Exercice 1 : Comprendre les tests existants**

#### 1.1 Analyser les tests unitaires

Ouvrez `tests/unit/items.service.test.js` :

```bash
# Ex√©cuter seulement ce fichier
node --test tests/unit/items.service.test.js
```

**‚ùì Questions d'analyse :**

1. Combien de tests sont d√©finis ? ****\_\_\_****
2. Quelles m√©thodes du service sont test√©es ? ****\_\_\_****
3. Comment les donn√©es de test sont-elles r√©initialis√©es ? ****\_\_\_****

#### 1.2 Analyser les tests de sch√©mas

Ouvrez `tests/unit/items.schema.test.js` :

**‚ùì Questions :**

1. Que teste `createItemSchema` ? ****\_\_\_****
2. Comment les erreurs de validation sont-elles v√©rifi√©es ? ****\_\_\_****
3. Quels cas limites sont test√©s ? ****\_\_\_****

#### 1.3 Ex√©cuter et comprendre les r√©sultats

```bash
npm run test:unit
```

**üìù Analysez la sortie :**

- Temps d'ex√©cution : ****\_\_\_****
- Nombre de tests pass√©s : ****\_\_\_****
- Couverture de code (si disponible) : ****\_\_\_****%

### **Exercice 2 : Cr√©er des tests unitaires**

#### 2.1 Tester une nouvelle m√©thode du service

Ajoutez cette m√©thode dans `src/services/items.service.js` :

```javascript
// M√©thode √† ajouter dans la classe ItemsService
getItemsByCategory(category) {
  return this.items.filter(item => item.category === category);
}

getItemsCountByCategory() {
  const counts = {};
  this.items.forEach(item => {
    counts[item.category] = (counts[item.category] || 0) + 1;
  });
  return counts;
}

getExpensiveItems(minPrice = 100) {
  return this.items.filter(item => item.price >= minPrice);
}
```

#### 2.2 √âcrire les tests correspondants

Cr√©ez `tests/unit/items.service.advanced.test.js` :

```javascript
import { describe, it, beforeEach } from "node:test";
import assert from "node:assert";
import { ItemsService } from "../../src/services/items.service.js";

describe("ItemsService - M√©thodes avanc√©es", () => {
  let service;

  beforeEach(() => {
    service = new ItemsService();
    service.reset(); // Remet les donn√©es par d√©faut
  });

  describe("getItemsByCategory()", () => {
    it("devrait retourner les items de la cat√©gorie electronics", () => {
      const electronics = service.getItemsByCategory("electronics");

      // V√©rifications √† compl√©ter
      assert.strictEqual(Array.isArray(electronics), true);
      assert.ok(electronics.length > 0);
      electronics.forEach((item) => {
        assert.strictEqual(item.category, "electronics");
      });
    });

    it("devrait retourner un tableau vide pour une cat√©gorie inexistante", () => {
      // TODO: Compl√©ter ce test
    });
  });

  describe("getItemsCountByCategory()", () => {
    it("devrait retourner le bon nombre d'items par cat√©gorie", () => {
      // TODO: Compl√©ter ce test
    });
  });

  describe("getExpensiveItems()", () => {
    it("devrait retourner les items au-dessus du prix minimum", () => {
      // TODO: Compl√©ter ce test
    });
  });
});
```

**üìù T√¢che :** Compl√©tez les tests marqu√©s TODO

#### 2.3 Ex√©cuter vos nouveaux tests

```bash
node --test tests/unit/items.service.advanced.test.js
```

### **Exercice 3 : Tests d'int√©gration API**

#### 3.1 Analyser les tests d'int√©gration existants

Ouvrez `tests/integration/api.test.js` :

**‚ùì Questions :**

1. Comment le serveur de test est-il d√©marr√© ? ****\_\_\_****
2. Quelle biblioth√®que est utilis√©e pour les requ√™tes HTTP ? ****\_\_\_****
3. Comment l'isolation entre tests est-elle assur√©e ? ****\_\_\_****

#### 3.2 Cr√©er de nouveaux tests d'int√©gration

Ajoutez ces tests dans `tests/integration/api.advanced.test.js` :

```javascript
import { describe, it, before, after, beforeEach } from "node:test";
import assert from "node:assert";

describe("API Advanced Integration Tests", () => {
  let server;
  let baseURL;

  before(async () => {
    // TODO: D√©marrer le serveur de test
    // Inspiration : regarder api.test.js
  });

  after(async () => {
    // TODO: Arr√™ter le serveur
  });

  beforeEach(async () => {
    // TODO: R√©initialiser les donn√©es
  });

  describe("Workflow complet CRUD", () => {
    it("devrait cr√©er, lire, modifier et supprimer un item", async () => {
      // √âtape 1 : Cr√©er un item
      const createResponse = await fetch(`${baseURL}/api/items`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: "Test Workflow Item",
          description: "Item pour test workflow",
          category: "electronics",
          price: 199.99,
        }),
      });

      assert.strictEqual(createResponse.status, 201);
      const createdItem = await createResponse.json();
      const itemId = createdItem.id;

      // √âtape 2 : Lire l'item cr√©√©
      // TODO: Compl√©ter

      // √âtape 3 : Modifier l'item
      // TODO: Compl√©ter

      // √âtape 4 : Supprimer l'item
      // TODO: Compl√©ter

      // √âtape 5 : V√©rifier qu'il n'existe plus
      // TODO: Compl√©ter
    });
  });

  describe("Tests de validation d'int√©gration", () => {
    it("devrait rejeter des donn√©es invalides avec le bon code d'erreur", async () => {
      // TODO: Tester diff√©rents cas d'erreur de validation
    });
  });

  describe("Tests de performance basiques", () => {
    it("devrait traiter 10 requ√™tes simultan√©es", async () => {
      const promises = [];
      for (let i = 0; i < 10; i++) {
        promises.push(fetch(`${baseURL}/api/items`));
      }

      const responses = await Promise.all(promises);
      responses.forEach((response) => {
        assert.strictEqual(response.status, 200);
      });
    });
  });
});
```

### **Exercice 4 : Tests avec mocks**

#### 4.1 Cr√©er un mock du service

Cr√©ez `tests/unit/items.controller.mock.test.js` :

```javascript
import { describe, it, beforeEach, mock } from "node:test";
import assert from "node:assert";
import { ItemsController } from "../../src/controllers/items.controller.js";

describe("ItemsController avec mocks", () => {
  let controller;
  let mockService;
  let mockReq;
  let mockRes;

  beforeEach(() => {
    // Mock du service
    mockService = {
      getAllItems: mock.fn(() => ["item1", "item2"]),
      getItemById: mock.fn(),
      createItem: mock.fn(),
      updateItem: mock.fn(),
      deleteItem: mock.fn(),
    };

    // Mock de la requ√™te Express
    mockReq = {
      body: {},
      params: {},
      query: {},
    };

    // Mock de la r√©ponse Express
    mockRes = {
      status: mock.fn().mockReturnThis(),
      json: mock.fn().mockReturnThis(),
      send: mock.fn().mockReturnThis(),
    };

    controller = new ItemsController(mockService);
  });

  describe("getAllItems", () => {
    it("devrait appeler le service et retourner les items", async () => {
      await controller.getAllItems(mockReq, mockRes);

      // V√©rifier que le service a √©t√© appel√©
      assert.strictEqual(mockService.getAllItems.mock.callCount(), 1);

      // V√©rifier que la r√©ponse est correcte
      assert.strictEqual(mockRes.json.mock.callCount(), 1);
      assert.deepStrictEqual(mockRes.json.mock.calls[0].arguments[0], [
        "item1",
        "item2",
      ]);
    });
  });

  describe("createItem", () => {
    it("devrait cr√©er un item et retourner 201", async () => {
      const newItem = { id: "1", name: "Test Item" };
      mockService.createItem.mock.mockImplementationOnce(() => newItem);
      mockReq.body = { name: "Test Item", category: "electronics", price: 10 };

      await controller.createItem(mockReq, mockRes);

      // TODO: Ajouter les v√©rifications
    });
  });
});
```

#### 4.2 Tests d'erreurs avec mocks

Ajoutez des tests pour les cas d'erreur :

```javascript
describe("Gestion d'erreurs", () => {
  it("devrait retourner 500 si le service lance une erreur", async () => {
    mockService.getAllItems.mock.mockImplementationOnce(() => {
      throw new Error("Service error");
    });

    await controller.getAllItems(mockReq, mockRes);

    // TODO: V√©rifier que le statut 500 est retourn√©
  });
});
```

### **Exercice 5 : Coverage et qualit√©**

#### 5.1 G√©n√©rer un rapport de couverture

```bash
# Si c8 est install√©
npx c8 npm test

# Sinon, analyser manuellement
npm test 2>&1 | grep -E "(pass|fail|todo)"
```

#### 5.2 Identifier les zones non test√©es

**üìù Analysez :**

- Quels fichiers ont moins de 80% de couverture ?
- Quelles fonctions ne sont pas test√©es ?
- Quels cas limites manquent ?

#### 5.3 Am√©liorer la couverture

Ajoutez des tests pour couvrir :

- Les cas d'erreur non test√©s
- Les branches conditionnelles
- Les validations edge cases

---

## üîß **Exercices avanc√©s**

### **Exercice 6 : Tests de r√©gression**

#### 6.1 Cr√©er un test de non-r√©gression

```javascript
// tests/regression/api.regression.test.js
describe("Tests de r√©gression", () => {
  it("ne devrait pas casser la compatibilit√© de l'API v1", async () => {
    // Tester que les anciennes requ√™tes fonctionnent toujours
  });
});
```

### **Exercice 7 : Tests de performance**

#### 7.1 Tester les temps de r√©ponse

```javascript
describe("Performance", () => {
  it("devrait r√©pondre en moins de 100ms", async () => {
    const start = Date.now();
    const response = await fetch(`${baseURL}/api/items`);
    const duration = Date.now() - start;

    assert.ok(duration < 100, `R√©ponse trop lente: ${duration}ms`);
  });
});
```

### **Exercice 8 : Tests de charge**

#### 8.1 Tester la charge concurrentielle

```javascript
it("devrait g√©rer 100 requ√™tes simultan√©es", async () => {
  const promises = Array.from({ length: 100 }, () =>
    fetch(`${baseURL}/api/items`)
  );

  const responses = await Promise.all(promises);
  const successCount = responses.filter((r) => r.status === 200).length;

  assert.ok(successCount >= 95, `Trop d'√©checs: ${100 - successCount}`);
});
```

---

## üìä **Validation des acquis**

### **Comp√©tences techniques**

- [ ] Je comprends la diff√©rence entre tests unitaires et d'int√©gration
- [ ] Je sais √©crire des tests avec Node.js Test Runner
- [ ] Je ma√Ætrise les mocks et stubs
- [ ] Je peux tester les cas d'erreur
- [ ] Je sais interpr√©ter la couverture de code

### **Comp√©tences pratiques**

- [ ] J'√©cris des tests avant de coder (TDD)
- [ ] Je teste tous les cas limites
- [ ] Je maintiens une couverture > 80%
- [ ] Je documente mes tests
- [ ] J'automatise l'ex√©cution des tests

### **Bonnes pratiques**

- [ ] Tests isol√©s et ind√©pendants
- [ ] Noms de tests descriptifs
- [ ] Organisation claire des fichiers de test
- [ ] Tests rapides et fiables
- [ ] Nettoyage apr√®s chaque test

---

## üéØ **Quiz de validation**

### 1. Quelle est la diff√©rence principale entre un mock et un stub ?

- [ ] Aucune diff√©rence
- [ ] Mock remplace compl√®tement, stub partiellement
- [ ] Stub est plus rapide
- [ ] Mock ne fonctionne qu'avec les classes

### 2. Pourquoi isoler les tests ?

- [ ] Pour la performance
- [ ] Pour √©viter les effets de bord
- [ ] Pour la lisibilit√©
- [ ] Toutes les r√©ponses

### 3. Que teste un test d'int√©gration ?

- [ ] Une fonction isol√©e
- [ ] L'interaction entre composants
- [ ] L'interface utilisateur
- [ ] La base de donn√©es uniquement

### 4. Quelle couverture de code viser ?

- [ ] 50%
- [ ] 80%
- [ ] 100%
- [ ] Peu importe

---

## ‚úÖ **Checklist finale**

Avant de passer au TP 5, v√©rifiez :

- [ ] ‚úÖ J'ai analys√© les tests existants
- [ ] ‚úÖ J'ai √©crit des tests unitaires
- [ ] ‚úÖ J'ai cr√©√© des tests d'int√©gration
- [ ] ‚úÖ J'ai utilis√© des mocks efficacement
- [ ] ‚úÖ J'ai test√© les cas d'erreur
- [ ] ‚úÖ J'ai v√©rifi√© la couverture de code
- [ ] ‚úÖ Tous mes tests passent
- [ ] ‚úÖ Je comprends l'importance des tests

---

## üöÄ **Pr√™t pour le niveau 5 ?**

Si toutes les cases sont coch√©es :

```bash
git add .
git commit -m "‚úÖ TP4 termin√© - Ma√Ætrise des tests unitaires et d'int√©gration"
git checkout tp-05-securite
```

**üéØ Dans le prochain TP :**

- Authentification JWT
- Middleware de s√©curit√©
- Protection des endpoints
- Gestion des r√¥les utilisateurs

---

## üí° **Points cl√©s √† retenir**

### **üß™ Philosophie des tests**

```
"Un code sans tests est un code cass√© par design" - Jacob Kaplan-Moss
```

### **üìà Pyramide des tests**

```
     /\
    /E2E\     ‚Üê Peu nombreux, lents, fiables
   /______\
  /  INT   \   ‚Üê Moyennement nombreux, moyens
 /__________\
/   UNIT     \  ‚Üê Nombreux, rapides, isol√©s
______________
```

### **üîÑ Cycle TDD (optionnel)**

1. **Red** : √âcrire un test qui √©choue
2. **Green** : √âcrire le code minimal pour passer
3. **Refactor** : Am√©liorer le code en gardant les tests verts

### **üõ°Ô∏è Avantages des tests**

- **Confiance** : Refactoring sans peur
- **Documentation** : Les tests expliquent le comportement
- **R√©gression** : D√©tection automatique des bugs
- **Design** : Force une API claire et testable
