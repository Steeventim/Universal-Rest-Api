# ‚ö° TP Niveau 3 : Validation avanc√©e

## üéØ **Objectifs**

- Ma√Ætriser la validation avanc√©e avec Zod
- Cr√©er des sch√©mas complexes et conditionnels
- Personnaliser les messages d'erreur
- Impl√©menter des validations m√©tier

## ‚è±Ô∏è **Dur√©e estim√©e :** 3-4 heures

---

## üìã **Pr√©requis**

### Ce que vous devez ma√Ætriser

- ‚úÖ CRUD complet avec POST, PUT, DELETE (TP 2)
- ‚úÖ Validation de base avec Zod
- ‚úÖ Gestion des codes de statut HTTP
- ‚úÖ Modifications des sch√©mas existants

### V√©rification rapide

```bash
# Test de base
curl -X POST http://localhost:3001/api/items \
  -H "Content-Type: application/json" \
  -d '{"name":"Test","category":"electronics","price":10}'

# Doit retourner 201 avec l'item cr√©√©
```

---

## üöÄ **Nouveaux concepts**

### **üß© Validation conditionnelle**

Validation qui d√©pend d'autres champs :

```javascript
// Si category = "electronics", warranty requis
z.object({
  category: z.string(),
  warranty: z.string().optional(),
}).refine(
  (data) => {
    if (data.category === "electronics") {
      return data.warranty !== undefined;
    }
    return true;
  },
  { message: "Warranty required for electronics" }
);
```

### **üé® Messages personnalis√©s**

```javascript
z.string().min(3, "Le nom doit contenir au moins 3 caract√®res");
z.number().max(10000, "Prix maximum: 10 000‚Ç¨");
```

### **üîó Sch√©mas compos√©s**

```javascript
const addressSchema = z.object({
  street: z.string(),
  city: z.string(),
  postal: z.string().regex(/^\d{5}$/),
});

const userSchema = z.object({
  name: z.string(),
  address: addressSchema, // Sch√©ma imbriqu√©
});
```

### **üìä Validation de tableaux**

```javascript
z.array(z.string()).min(1, "Au moins un tag requis");
z.array(itemSchema).max(100, "Maximum 100 items");
```

---

## üß™ **Exercices pratiques**

### **Exercice 1 : Am√©liorer le sch√©ma des items**

#### 1.1 Ajouter des champs optionnels

Modifiez `src/schemas/items.schema.js` pour ajouter :

```javascript
const itemSchema = z.object({
  // Champs existants...
  tags: z.array(z.string()).optional().default([]),
  inStock: z.boolean().default(true),
  discount: z.number().min(0).max(100).optional(),
  weight: z.number().positive().optional(),
  dimensions: z
    .object({
      length: z.number().positive(),
      width: z.number().positive(),
      height: z.number().positive(),
    })
    .optional(),
});
```

#### 1.2 Tester les nouveaux champs

Cr√©ez un item avec la structure √©tendue :

```json
{
  "name": "Smartphone Pro",
  "description": "Dernier mod√®le avec 5G",
  "category": "electronics",
  "price": 899.99,
  "tags": ["5G", "premium", "waterproof"],
  "inStock": true,
  "discount": 10,
  "weight": 0.185,
  "dimensions": {
    "length": 15.7,
    "width": 7.8,
    "height": 0.89
  }
}
```

### **Exercice 2 : Validation conditionnelle**

#### 2.1 Garantie obligatoire pour l'√©lectronique

Ajoutez une r√®gle : les produits √©lectroniques doivent avoir une garantie.

```javascript
export const createItemSchema = itemSchema.omit({ id: true }).refine(
  (data) => {
    if (data.category === "electronics") {
      return data.warranty !== undefined && data.warranty.length > 0;
    }
    return true;
  },
  {
    message: "La garantie est obligatoire pour les produits √©lectroniques",
    path: ["warranty"],
  }
);
```

N'oubliez pas d'ajouter `warranty` au sch√©ma de base :

```javascript
warranty: z.string().optional();
```

#### 2.2 Tester la validation conditionnelle

**Test 1 - Electronics sans garantie (doit √©chouer) :**

```json
{
  "name": "Laptop",
  "category": "electronics",
  "price": 1200
}
```

**Test 2 - Electronics avec garantie (doit r√©ussir) :**

```json
{
  "name": "Laptop",
  "category": "electronics",
  "price": 1200,
  "warranty": "2 ans constructeur"
}
```

**Test 3 - Books sans garantie (doit r√©ussir) :**

```json
{
  "name": "Roman",
  "category": "books",
  "price": 15
}
```

### **Exercice 3 : Messages d'erreur personnalis√©s**

#### 3.1 Personnaliser tous les messages

Remplacez les validations par des messages en fran√ßais :

```javascript
const itemSchema = z.object({
  name: z
    .string()
    .min(1, "Le nom est obligatoire")
    .max(100, "Le nom ne peut pas d√©passer 100 caract√®res"),

  description: z
    .string()
    .max(500, "La description ne peut pas d√©passer 500 caract√®res")
    .optional(),

  price: z
    .number({
      required_error: "Le prix est obligatoire",
      invalid_type_error: "Le prix doit √™tre un nombre",
    })
    .positive("Le prix doit √™tre positif")
    .max(100000, "Prix maximum: 100 000‚Ç¨"),

  category: z.enum(validCategories, {
    errorMap: () => ({
      message: `La cat√©gorie doit √™tre: ${validCategories.join(", ")}`,
    }),
  }),

  tags: z
    .array(z.string().min(1, "Les tags ne peuvent pas √™tre vides"))
    .max(10, "Maximum 10 tags autoris√©s")
    .optional()
    .default([]),

  inStock: z
    .boolean({
      invalid_type_error: "inStock doit √™tre true ou false",
    })
    .default(true),
});
```

#### 3.2 Tester les messages personnalis√©s

Testez ces cas d'erreur et v√©rifiez les messages :

```json
// Prix n√©gatif
{"name": "Test", "category": "books", "price": -10}

// Nom trop long
{"name": "A".repeat(101), "category": "books", "price": 10}

// Trop de tags
{"name": "Test", "category": "books", "price": 10, "tags": ["1","2","3","4","5","6","7","8","9","10","11"]}
```

### **Exercice 4 : Validation de relations**

#### 4.1 Cr√©er un sch√©ma de cat√©gorie

Cr√©ez `src/schemas/category.schema.js` :

```javascript
import { z } from "zod";

export const categorySchema = z.object({
  id: z.string(),
  name: z.string().min(1, "Nom de cat√©gorie requis"),
  description: z.string().optional(),
  parentId: z.string().optional(), // Cat√©gorie parente
  allowedFields: z.array(z.string()).default([]),
});

// Exemples de cat√©gories avec champs sp√©cifiques
const categoryRules = {
  electronics: ["warranty", "brand", "model"],
  books: ["author", "isbn", "publisher"],
  clothing: ["size", "color", "material"],
  home: ["room", "material"],
};
```

#### 4.2 Validation dynamique selon la cat√©gorie

Modifiez le sch√©ma des items pour valider selon la cat√©gorie :

```javascript
export const createItemSchema = itemSchema
  .omit({ id: true })
  .superRefine((data, ctx) => {
    // Validation garantie pour electronics
    if (data.category === "electronics" && !data.warranty) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Garantie obligatoire pour l'√©lectronique",
        path: ["warranty"],
      });
    }

    // Validation ISBN pour books
    if (data.category === "books" && data.isbn) {
      const isbnRegex =
        /^(?:ISBN(?:-1[03])?:? )?(?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$/;
      if (!isbnRegex.test(data.isbn)) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: "Format ISBN invalide",
          path: ["isbn"],
        });
      }
    }
  });
```

### **Exercice 5 : Validation de business rules**

#### 5.1 R√®gles m√©tier complexes

Ajoutez des validations business :

```javascript
export const createItemSchema = itemSchema
  .omit({ id: true })
  .superRefine((data, ctx) => {
    // R√®gle 1: Discount seulement si prix > 50‚Ç¨
    if (data.discount && data.discount > 0 && data.price <= 50) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Remise disponible seulement pour les articles > 50‚Ç¨",
        path: ["discount"],
      });
    }

    // R√®gle 2: Produits lourds doivent avoir des dimensions
    if (data.weight && data.weight > 10 && !data.dimensions) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Dimensions obligatoires pour les produits > 10kg",
        path: ["dimensions"],
      });
    }

    // R√®gle 3: Tags pertinents selon cat√©gorie
    if (data.tags && data.tags.length > 0) {
      const categoryTags = {
        electronics: ["bluetooth", "wifi", "4k", "hd", "wireless"],
        books: ["fiction", "non-fiction", "hardcover", "paperback"],
        clothing: ["cotton", "polyester", "small", "medium", "large"],
        home: ["wood", "metal", "plastic", "ceramic"],
      };

      const validTags = categoryTags[data.category] || [];
      const invalidTags = data.tags.filter(
        (tag) => validTags.length > 0 && !validTags.includes(tag.toLowerCase())
      );

      if (invalidTags.length > 0) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Tags non pertinents pour ${
            data.category
          }: ${invalidTags.join(", ")}`,
          path: ["tags"],
        });
      }
    }
  });
```

#### 5.2 Tester les r√®gles m√©tier

**Test A - Discount sur produit pas cher :**

```json
{
  "name": "Livre pas cher",
  "category": "books",
  "price": 15,
  "discount": 20
}
```

**Test B - Produit lourd sans dimensions :**

```json
{
  "name": "Machine lourde",
  "category": "home",
  "price": 500,
  "weight": 25
}
```

**Test C - Tags non pertinents :**

```json
{
  "name": "Roman",
  "category": "books",
  "price": 20,
  "tags": ["bluetooth", "wifi"]
}
```

---

## üîß **Validation c√¥t√© service**

### **Exercice 6 : Validation dans les services**

#### 6.1 Ajouter des validations m√©tier dans le service

Modifiez `src/services/items.service.js` :

```javascript
class ItemsService {
  // Validation business avant cr√©ation
  async validateBusinessRules(itemData) {
    const errors = [];

    // V√©rifier unicit√© du nom
    const existingItem = this.mockData.find(
      (item) => item.name.toLowerCase() === itemData.name.toLowerCase()
    );
    if (existingItem) {
      errors.push("Un produit avec ce nom existe d√©j√†");
    }

    // V√©rifier coh√©rence prix/cat√©gorie
    const categoryPriceRanges = {
      electronics: { min: 10, max: 50000 },
      books: { min: 5, max: 200 },
      clothing: { min: 10, max: 1000 },
      home: { min: 5, max: 10000 },
    };

    const range = categoryPriceRanges[itemData.category];
    if (range && (itemData.price < range.min || itemData.price > range.max)) {
      errors.push(
        `Prix incoh√©rent pour ${itemData.category}: attendu entre ${range.min}‚Ç¨ et ${range.max}‚Ç¨`
      );
    }

    return errors;
  }

  async createItem(itemData) {
    // Validation business
    const businessErrors = await this.validateBusinessRules(itemData);
    if (businessErrors.length > 0) {
      throw new Error(`Erreurs m√©tier: ${businessErrors.join(", ")}`);
    }

    // Cr√©ation normale
    const newItem = {
      id: String(this.mockData.length + 1),
      ...itemData,
      createdAt: new Date().toISOString(),
    };

    this.mockData.push(newItem);
    return newItem;
  }
}
```

#### 6.2 G√©rer les erreurs m√©tier dans le controller

Modifiez `src/controllers/items.controller.js` :

```javascript
async createItem(req, res) {
  try {
    const item = await itemsService.createItem(req.body);
    res.status(201).json(item);
  } catch (error) {
    if (error.message.startsWith("Erreurs m√©tier:")) {
      return res.status(422).json({
        error: "Validation m√©tier √©chou√©e",
        details: error.message.replace("Erreurs m√©tier: ", "")
      });
    }
    res.status(500).json({ error: "Erreur serveur" });
  }
}
```

---

## üìä **Tests et validation**

### **Exercice 7 : Cr√©er des tests de validation**

#### 7.1 Tests unitaires pour les sch√©mas

Cr√©ez `tests/validation.test.js` :

```javascript
import { describe, it } from "node:test";
import assert from "node:assert";
import { createItemSchema } from "../src/schemas/items.schema.js";

describe("Validation des items", () => {
  it("devrait accepter un item valide", () => {
    const validItem = {
      name: "Test Product",
      category: "electronics",
      price: 100,
      warranty: "1 an",
    };

    const result = createItemSchema.safeParse(validItem);
    assert.strictEqual(result.success, true);
  });

  it("devrait rejeter un item √©lectronique sans garantie", () => {
    const invalidItem = {
      name: "Test Product",
      category: "electronics",
      price: 100,
    };

    const result = createItemSchema.safeParse(invalidItem);
    assert.strictEqual(result.success, false);
    assert.ok(
      result.error.errors.some((err) => err.message.includes("garantie"))
    );
  });
});
```

#### 7.2 Ex√©cuter les tests

```bash
npm test
```

---

## üéØ **Validation des acquis**

### **Quiz avanc√©**

#### 1. Quelle est la diff√©rence entre `.refine()` et `.superRefine()` ?

- [ ] Aucune diff√©rence
- [ ] superRefine permet plusieurs erreurs
- [ ] refine est plus performant
- [ ] superRefine est deprecated

#### 2. Comment valider qu'un champ est requis seulement si un autre a une valeur sp√©cifique ?

- [ ] Avec z.conditional()
- [ ] Avec .refine()
- [ ] Avec .when()
- [ ] Impossible avec Zod

#### 3. Quel code de statut pour une erreur de business rules ?

- [ ] 400 Bad Request
- [ ] 422 Unprocessable Entity
- [ ] 409 Conflict
- [ ] 500 Server Error

---

## ‚úÖ **Checklist finale**

### **Sch√©mas avanc√©s**

- [ ] ‚úÖ Champs optionnels avec valeurs par d√©faut
- [ ] ‚úÖ Validation conditionnelle impl√©ment√©e
- [ ] ‚úÖ Messages d'erreur personnalis√©s
- [ ] ‚úÖ Sch√©mas compos√©s utilis√©s

### **Validation m√©tier**

- [ ] ‚úÖ R√®gles business impl√©ment√©es
- [ ] ‚úÖ Validation dans les services
- [ ] ‚úÖ Gestion des erreurs 422
- [ ] ‚úÖ Tests de validation cr√©√©s

### **Cas d'usage complexes**

- [ ] ‚úÖ Validation selon cat√©gorie
- [ ] ‚úÖ R√®gles prix/remise
- [ ] ‚úÖ Validation unicit√©
- [ ] ‚úÖ Coh√©rence des donn√©es

---

## üöÄ **Pr√™t pour le niveau 4 ?**

Si toutes les cases sont coch√©es :

```bash
git add .
git commit -m "‚úÖ TP3 termin√© - Validation avanc√©e ma√Ætris√©e"
git checkout tp-04-tests
```

**üéØ Dans le prochain TP :**

- Tests unitaires et d'int√©gration
- Mocking et stubbing
- Tests de performance
- Couverture de code

---

## üí° **Points cl√©s √† retenir**

### **üé® Validation avanc√©e**

- `refine()` pour une validation simple
- `superRefine()` pour des validations multiples
- Messages personnalis√©s pour UX
- Validation conditionnelle selon contexte

### **üè¢ R√®gles m√©tier**

- Validation au niveau service
- Codes 422 pour erreurs business
- S√©paration validation technique/m√©tier
- Tests sp√©cifiques aux r√®gles

### **‚ö° Performance**

- Validation lazy quand possible
- Early return sur erreurs
- Cache des sch√©mas compil√©s
- Optimisation des regex complexes
